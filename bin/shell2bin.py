#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
shell2bin.py (public version)
=============================

Convert any shell script (e.g. a Bash tool) into a native ELF binary that you
can drop into /usr/bin, /usr/local/bin, etc.

How it works (high-level):
  - Reads a shell script as bytes.
  - Applies a simple XOR “obfuscation” so the script is not stored as plain text
    inside the binary (NOT cryptographically secure, just light obfuscation).
  - Generates a small C program that embeds the obfuscated bytes.
  - At runtime, the C program:
      * De-obfuscates the script into memory.
      * Writes it to a temporary file in /tmp.
      * Marks it executable via chmod(0700).
      * Executes it via execve() → the kernel reads the shebang (#!/usr/bin/env bash
        or whatever you use), so the correct interpreter is used.
      * Passes through all command-line arguments from the wrapper binary.
      * Cleans up the temporary file after execution.

Example:
    python3 shell2bin.py vopk.sh vopk
    sudo cp vopk /usr/bin/vopk
    vopk doctor
"""

import argparse
import subprocess
import tempfile
from pathlib import Path
from typing import ByteString


def xor_encrypt(data: ByteString, key: int) -> bytes:
    """Apply a simple XOR to each byte (for light obfuscation only)."""
    return bytes(b ^ key for b in data)


def bytes_to_c_array(data: bytes) -> str:
    """
    Convert a bytes object into a C-style array initializer, e.g.
    0x12, 0x34, ...
    """
    items = [f"0x{b:02x}" for b in data]
    lines = []
    for i in range(0, len(items), 16):
        lines.append(", ".join(items[i:i + 16]))
    return ",\n    ".join(lines)


def generate_c_source(enc_script: bytes, key: int, tool_name: str) -> str:
    """
    Generate the full C source code for the wrapper binary that:
      - De-obfuscates the embedded script.
      - Writes it to a temporary file.
      - Executes it via execve(), using the shebang in the script.
    """

    arr = bytes_to_c_array(enc_script)

    return f"""\
/*
 * Auto-generated by shell2bin.py
 * Embedded tool name: {tool_name}
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>

static const unsigned char enc_script[] = {{
    {arr}
}};

static const unsigned char XOR_KEY = 0x{key:02x};

int main(int argc, char **argv, char **envp) {{
    char template[] = "/tmp/.{tool_name}-XXXXXX";
    int fd;
    unsigned char *buf = NULL;
    ssize_t written;
    pid_t pid;
    int status = 0;

    size_t script_len = sizeof(enc_script);

    if (script_len == 0) {{
        fprintf(stderr, "embedded script is empty\\n");
        return 1;
    }}

    fd = mkstemp(template);
    if (fd == -1) {{
        perror("mkstemp");
        return 1;
    }}

    buf = (unsigned char *)malloc(script_len);
    if (!buf) {{
        perror("malloc");
        close(fd);
        unlink(template);
        return 1;
    }}

    // De-obfuscate (XOR) into buffer
    for (size_t i = 0; i < script_len; ++i) {{
        buf[i] = enc_script[i] ^ XOR_KEY;
    }}

    // Write script to temporary file
    written = write(fd, buf, script_len);
    free(buf);
    buf = NULL;

    if (written < 0 || (size_t)written != script_len) {{
        perror("write");
        close(fd);
        unlink(template);
        return 1;
    }}

    if (fchmod(fd, 0700) == -1) {{
        perror("fchmod");
        close(fd);
        unlink(template);
        return 1;
    }}

    close(fd);

    // Fork and execve() the temporary script (shebang-aware)
    pid = fork();
    if (pid < 0) {{
        perror("fork");
        unlink(template);
        return 1;
    }} else if (pid == 0) {{
        // Child: build argv for the script
        char **child_argv = (char **)malloc(sizeof(char *) * (argc + 1));
        if (!child_argv) {{
            perror("malloc");
            _exit(1);
        }}

        child_argv[0] = template;    // script name
        for (int i = 1; i < argc; ++i) {{
            child_argv[i] = argv[i]; // forward original arguments
        }}
        child_argv[argc] = NULL;

        execve(template, child_argv, envp);
        // If execve returns, an error occurred
        perror("execve");
        _exit(127);
    }} else {{
        // Parent: wait for child, then remove temp file
        if (waitpid(pid, &status, 0) == -1) {{
            perror("waitpid");
            unlink(template);
            return 1;
        }}

        unlink(template);

        if (WIFEXITED(status)) {{
            return WEXITSTATUS(status);
        }} else if (WIFSIGNALED(status)) {{
            fprintf(stderr, "child terminated by signal %d\\n", WTERMSIG(status));
            return 128 + WTERMSIG(status);
        }} else {{
            return 1;
        }}
    }}
}}
"""


def build_binary(shell_path: Path, output_path: Path, key: int = 0xA5, gcc: str = "gcc") -> None:
    """
    Read the shell script, generate the C wrapper source, and compile it to a
    native ELF binary using gcc.
    """
    if not shell_path.is_file():
        raise FileNotFoundError(f"Shell script not found: {shell_path}")

    script_bytes = shell_path.read_bytes()

    if not script_bytes.startswith(b"#!"):
        print(
            "[*] Warning: script does not start with a shebang (#!). "
            "The kernel will still try to execute it, but you should usually "
            "start your script with something like '#!/usr/bin/env bash'.",
            flush=True,
        )

    enc = xor_encrypt(script_bytes, key)
    tool_name = output_path.name

    c_source = generate_c_source(enc, key, tool_name)

    with tempfile.TemporaryDirectory() as tmpdir:
        c_file = Path(tmpdir) / f"{tool_name}.c"
        c_file.write_text(c_source, encoding="utf-8")

        cmd = [gcc, "-Os", "-s", str(c_file), "-o", str(output_path)]
        print("[*] Running:", " ".join(cmd))
        subprocess.check_call(cmd)

    mode = output_path.stat().st_mode
    output_path.chmod(mode | 0o111)
    print(f"[*] Built binary: {output_path}")


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Convert a shell script into a native ELF binary wrapper."
    )
    parser.add_argument("input", help="Path to the shell script (e.g. vopk.sh)")
    parser.add_argument("output", help="Path to the output binary (e.g. vopk)")
    parser.add_argument(
        "--key",
        type=lambda x: int(x, 0),
        default=0xA5,
        help="XOR key as int or hex (default: 0xA5)",
    )
    parser.add_argument(
        "--gcc",
        default="gcc",
        help="GCC executable name/path (default: gcc)",
    )

    args = parser.parse_args()

    shell_path = Path(args.input)
    output_path = Path(args.output)

    build_binary(shell_path, output_path, key=args.key, gcc=args.gcc)


if __name__ == "__main__":
    main()

